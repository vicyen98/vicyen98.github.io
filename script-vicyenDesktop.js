let box = {
    "file_spec": 1,
    "file_creator": "A text editor",
    "file_author": "Jason Ku",
    "file_classes": ["singleModel"],
    "frame_title": "3D box folding with wing",
    "frame_classes": ["foldedForm"],
    "frame_attributes": ["3D"],
    "vertices_coords": [
      [-1,-1,-1],
      [-1, 1,-1],
      [ 1, 1,-1],
      [ 1,-1,-1],
      [-1,-1, 1],
      [-1,-1, 1],
      [-1, 1, 1],
      [-1, 1, 1],
      [ 1, 1, 1],
      [ 1, 1, 1],
      [ 1,-1, 1],
      [ 1,-1, 1],
      [-1,-1,-1],
      [-1, 1,-1],
      [ 1,-1,-1],
      [ 1,-1, 1],
      [-1,-1, 1],
      [ 1,-1, 1],
      [-1,-1, 1],
      [ 1,-1, 1],
      [1,0,0],
      [-0.292893218813453,-0.292893218813453,0],
      [0,1,0],
      [ 1, 1, 1],
      [ 1, 1, 1],
      [1.707106781186547, 0, 1.707106781186547],
      [1.707106781186547, 0, 1.707106781186547],
      [1.707106781186547, 0, 1.707106781186547],
      [1,0.5,1],
      [1.530330085889911,-0.25,1.530330085889911],
      [1,0.5,1],
      [1.353553390593274, 0.5,1.353553390593274],
      [1.707106781186547,   0,1.707106781186547],
      [1.353553390593274, 0.5,1.353553390593274],
      [1.353553390593274,-0.5,1.353553390593274],
      [-1,-0.414213562373095,0.414213562373095],
      [-1,-1,-0.171572875253810],
      [-0.414213562373095,-1,0.414213562373095],
      [-1,-1,-0.171572875253810]
    ],
    "faces_vertices": [
      [0,1,2,3],
      [0,3,11,4],
      [0,5,6,1],
      [1,7,8,2],
      [2,9,10,3],
      [7,16,17,8],
      [9,18,10],
      [9,19,18],
      [10,18,38,14],
      [14,38,37],
      [7,13,36,16],
      [13,35,36],
      [2,15,9],
      [2,8,15],
      [3,10,20],
      [10,14,20],
      [11,20,14],
      [3,20,11],
      [0,4,21],
      [4,12,21],
      [5,21,12],
      [0,21,5],
      [1,22,7],
      [1,6,22],
      [6,13,22],
      [7,22,13],
      [8,26,15],
      [8,17,26],
      [17,24,26],
      [15,26,24],
      [9,15,25],
      [15,23,25],
      [19,25,23],
      [9,25,19],
      [15,24,27],
      [15,27,23],
      [24,28,29,27],
      [23,27,29,30],
      [28,31,32,29],
      [29,32,33,30],
      [31,34,32],
      [32,34,33]
    ], 
    "faceOrders": [
      [ 8, 1,-1],
      [ 9, 8,-1],
      [10, 2,-1],
      [11,10,-1],
      [22, 3,-1],
      [23,22, 1],
      [24,23,-1],
      [25,24, 1],
      [14, 4,-1],
      [17,14, 1],
      [16,17,-1],
      [15,16, 1],
      [21,18, 1],
      [20,21,-1],
      [19,20, 1],
      [ 7, 5,-1],
      [ 6, 7, 1],
      [12,13,-1],
      [ 4,12, 1],
      [27,41, 1],
      [33,27,-1],
      [30,33, 1],
      [26,30,-1],
      [29,26, 1],
      [31,29,-1],
      [32,31, 1],
      [28,32,-1],
      [35,28, 1],
      [37,35,-1],
      [39,37, 1],
      [38,39,-1],
      [36,38, 1],
      [34,36,-1],
      [40,34, 1]
    ],
    "edges_vertices": [
      [ 5,12],
      [ 5, 6],
      [ 6,13],
      [13,35],
      [35,36],
      [16,36],
      [16,17],
      [17,24],
      [24,28],
      [28,31],
      [31,34],
      [33,34],
      [30,33],
      [23,30],
      [19,23],
      [18,19],
      [18,38],
      [37,38],
      [14,37],
      [11,14],
      [ 4,11],
      [ 4,12],
      [ 0, 1],
      [ 1, 2],
      [ 2, 3],
      [ 0, 3],
      [ 0, 4],
      [ 0, 5],
      [ 1, 6],
      [ 1, 7],
      [ 2, 8],
      [ 2, 9],
      [ 3,10],
      [ 3,11],
      [ 7,13],
      [ 7, 8],
      [ 7,16],
      [13,36],
      [10,14],
      [ 9,10],
      [10,18],
      [14,38],
      [ 0,21],
      [ 4,21],
      [12,21],
      [ 5,21],
      [ 3,20],
      [10,20],
      [14,20],
      [11,20],
      [13,22],
      [ 7,22],
      [ 1,22],
      [ 6,22],
      [ 2,15],
      [ 9,18],
      [ 8,17],
      [ 9,19],
      [ 8,15],
      [ 9,15],
      [ 8,26],
      [17,26],
      [24,26],
      [15,26],
      [ 9,25],
      [19,25],
      [23,25],
      [15,25],
      [15,24],
      [15,23],
      [15,27],
      [24,27],
      [23,27],
      [27,29],
      [29,30],
      [28,29],
      [29,32],
      [32,33],
      [31,32],
      [32,34]
    ],
    "edges_assignment": [
      "B",
      "B",
      "B",
      "B",
      "B",
      "B",
      "B",
      "B",
      "B",
      "B",
      "B",
      "B",
      "B",
      "B",
      "B",
      "B",
      "B",
      "B",
      "B",
      "B",
      "B",
      "B",
      "V",
      "V",
      "V",
      "V",
      "V",
      "V",
      "V",
      "V",
      "V",
      "M",
      "V",
      "V",
      "V",
      "V",
      "V",
      "V",
      "V",
      "V",
      "V",
      "V",
      "M",
      "M",
      "M",
      "V",
      "M",
      "M",
      "M",
      "V",
      "M",
      "M",
      "M",
      "V",
      "V",
      "M",
      "M",
      "V",
      "M",
      "V",
      "V",
      "V",
      "V",
      "M",
      "M",
      "M",
      "M",
      "V",
      "V",
      "M",
      "V",
      "V",
      "V",
      "M",
      "M",
      "M",
      "V",
      "M",
      "M",
      "M"
    ]
  };

let sampleDic = {
  20: [[3,20],[10,20],[14,20],[11,20]] , 
  21: [[0,21],[4,21],[12,21],[5,21]] ,
  22: [[13,22],[7,22],[1,22],[6,22]]
};


let FV = [];
let FC = [];

console.log(box);
console.log(box.vertices_coords);
console.log(box.edges_vertices);
console.log(box.edges_assignment);
console.log(box.faces_vertices);

const substituteIndexes = (coordinates, indexArray) => {
    return indexArray.map(indices => indices.map(index => coordinates[index]));
  };

const generateSurfaceColors = (numSurfaces) => {
  const getRandomHex = () => Math.floor(Math.random() * 256);
  const colors = [];
  for (let i = 0; i < numSurfaces; i++) {
      let color = (getRandomHex() << 16) | (getRandomHex() << 8) | getRandomHex();
      while ( // Ensure the color is different from the previous one
          i > 0 &&
          color === colors[i - 1]
      ) {
          color = (getRandomHex() << 16) | (getRandomHex() << 8) | getRandomHex();
      }
      colors.push(color);
  }
  return colors;
};

import * as THREE from 'three';
import { TrackballControls } from 'https://threejsfundamentals.org/threejs/resources/threejs/r132/examples/jsm/controls/TrackballControls.js';

const setup = () =>{
  document.body.style.margin = 0;
  document.body.style.padding = 0;
  const [w, h] = [window.innerWidth, window.innerHeight];
  const scene = new THREE.Scene();
  const s = 3;
  const camera = new THREE.OrthographicCamera(-s, s, s*h/w, -s*h/w, 0, 2*s);
  camera.position.z = s;
  const renderer = new THREE.WebGLRenderer();
  renderer.setSize(w, h);
  renderer.setClearColor(0xeeeeee);
  document.body.appendChild(renderer.domElement);

  let mouse = undefined;
  let change = undefined;

  // rescaledCoordinates = rescaleCoordinates(extractedData.vertices_coords);
  // FV = substituteIndexes(rescaledCoordinates, extractedData.faces_vertices);
  FV = substituteIndexes(box.vertices_coords, box.faces_vertices);
  FC = generateSurfaceColors(FV.length);
  console.log("FV:")
  console.log(FV);
  console.log("FC:");
  console.log(FC);

  //Finding Flat Degree Vertices
  let filteredEdgesVertices = filterEdgesByAssignment(box.edges_vertices, box.edges_assignment, targetAssignments);
  console.log("filteredEdgesVertices:");
  console.log(filteredEdgesVertices);
  let nodeAssociatedEdges = createNodeAssociatedEdges(filteredEdgesVertices);
  console.log("nodeAssociatedEdges:");
  console.log(nodeAssociatedEdges);
  let xDegreeVertex = 4;
  let xDegreeNodeAssociatedEdges = filterNodeAssociatedEdgesByDegree(nodeAssociatedEdges, xDegreeVertex);
  console.log("Degree 4 Vertices:");
  console.log(xDegreeNodeAssociatedEdges);

  generateDegFourEdgesSequence(sampleDic, box.faces_vertices);

  const update = () => {
      while (scene.children.length > 0) {
          scene.remove(scene.children[0]);
      }
      if (change != undefined) {
          const [dx, dy] = change.map(a => a*Math.PI/180);
          const rotation = new THREE.Quaternion()
              .setFromEuler(new THREE.Euler(dy, dx, 0, 'XYZ'));
          scene.quaternion.multiplyQuaternions(rotation, scene.quaternion);
      }
      for (let i = 0; i < FV.length; ++i) {
          const [P, color] = [FV[i], FC[i]];
          // Convert vertices to Float32Array
          const vertices = new Float32Array(P.flat());

          // Create a BufferGeometry
          const geometry = new THREE.BufferGeometry();
          geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));

          // Define indices for the shape (triangle fan)
          const indices = [];
          for (let i = 1; i <= P.length - 2; i++) {
              indices.push(0, i, i + 1);
          }

          geometry.setIndex(indices);

          // Create a material with the specified color
          const material = new THREE.MeshBasicMaterial({ color , transparent: true, opacity: 0.5});

          // Create a mesh using the geometry and material
          const mesh = new THREE.Mesh(geometry, material);
          scene.add(mesh);
      }
      renderer.render(scene, camera);
  };
  renderer.domElement.onmousedown = (e) => {
    mouse = [e.offsetX, e.offsetY];
    update();
  };

  renderer.domElement.onmouseup = (e) => {
    mouse = undefined;
    update();
  };

  renderer.domElement.onmousemove = (e) => {
    if (mouse == undefined) { return; }
    change = [e.offsetX - mouse[0], e.offsetY - mouse[1]];
    mouse = [e.offsetX, e.offsetY];
    update();
  };
  update();
};


//Finding Flat Degree 4 Vertices

const targetAssignments = ["V", "M"];

const filterEdgesByAssignment = (edgesVertices, edgesAssignment, targetAssignments) => {
  if (edgesVertices.length !== edgesAssignment.length) {
    throw new Error("Input arrays must have the same length");
  }

  const edges = edgesVertices.map((vertices, index) => ({ vertices, assignment: edgesAssignment[index] }));

  const filteredEdges = edges.filter(edge => targetAssignments.includes(edge.assignment));

  const filteredVertices = filteredEdges.map(edge => edge.vertices);

  return filteredVertices;
};

const createNodeAssociatedEdges = (filteredEdgesVertices) => {
  const nodeAssociatedEdges = {};

  // Iterate through each edge in the filtered edges
  filteredEdgesVertices.forEach(([node1, node2]) => {
    // Update or create an entry for node1
    if (!nodeAssociatedEdges[node1]) {
      nodeAssociatedEdges[node1] = [];
    }
    nodeAssociatedEdges[node1].push([node1, node2]);

    // Update or create an entry for node2
    if (!nodeAssociatedEdges[node2]) {
      nodeAssociatedEdges[node2] = [];
    }
    nodeAssociatedEdges[node2].push([node1, node2]);
  });

  return nodeAssociatedEdges;
};

const filterNodeAssociatedEdgesByDegree = (nodeAssociatedEdges, xDegreeVertex) => {
  const xDegreeNodeAssociatedEdges = {};

  // Iterate through each key-value pair in nodeAssociatedEdges
  Object.entries(nodeAssociatedEdges).forEach(([node, edges]) => {
    // Filter edges based on xDegreeVertex
    if (edges.length === xDegreeVertex) {
      xDegreeNodeAssociatedEdges[node] = edges;
    }
  });

  return xDegreeNodeAssociatedEdges;
};

const generateDegFourEdgesSequence = (degFourDic, facesVertices) => {
  let associatedVertices = [];
  let sortedAssociatedVertices = [];
  let sortedDic = {};

  

  console.log("associatedVertices:");
  console.log(associatedVertices);
  console.log("sortedAssociatedVertices:");
  console.log(sortedAssociatedVertices);
  console.log("sortedDic:");
  console.log(sortedDic);
};


//End of Finding Flat Degree 4 Vertices

setup();